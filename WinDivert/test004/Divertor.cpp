#include "Divertor.h"
#include "Error.h"
#include "Debugger.h"
#include <windivert.h>
#include <vector>
#include "structures.h"
#include "Client.h"

using namespace std;

//typedef struct
//{
//    WINDIVERT_IPHDR  ip;
//    WINDIVERT_TCPHDR tcp;
//} PACKET, *PPACKET;
//
//typedef struct 
//{
//    PACKET header;
//    UINT8 data[];
//	//UINT8* data;
//} DATAPACKET, *PDATAPACKET;

//const char block_data[] = 
//	"HTTP/1.1 400 Bad Request\r\n"
//	"Server: CloudFront\r\n"
//	"Date: Sat, 30 Sep 2017 08:06:51 GMT\r\n"
//	"Content-Type: text/html\r\n"
//	"Content-Length: 551\r\n"
//	"Connection: close\r\n"
//	"X-Cache: Error from cloudfront\r\n"
//	"Via: 1.1 c6d88d36c0be0174a24748de08dfae6b.cloudfront.net (CloudFront)\r\n"
//	"X-Amz-Cf-Id: K4vqVxFPID7WYDTwsOBUc72KJYMVkhnH1vYj-2YpikNKT6ewp3il0w==\r\n\r\n"
//	"<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">"
//	"<HTML><HEAD><META HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html; charset=iso-8859-1\">"
//	"<TITLE>ERROR: The request could not be satisfied</TITLE>"
//	"</HEAD><BODY>"
//	"<H1>ERROR</H1>"
//	"<H2>The request could not be satisfied.</H2>"
//	"<HR noshade size=\"1px\">"
//	"Bad request."
//	"<BR clear=\"all\">"
//	"<HR noshade size=\"1px\">"
//	"<PRE>"
//	"Generated by cloudfront (CloudFront)"
//	"Request ID: K4vqVxFPID7WYDTwsOBUc72KJYMVkhnH1vYj-2YpikNKT6ewp3il0w=="
//	"</PRE>"
//	"<ADDRESS>"
//	"</ADDRESS>"
//	"</BODY></HTML>";


//static void PacketInit(PPACKET packet)
//{
//	memset(packet, 0, sizeof(PACKET));
//	packet->ip.Version = 4;
//	packet->ip.HdrLength = sizeof(WINDIVERT_IPHDR) / sizeof(UINT32);
//	packet->ip.Length = htons(sizeof(PACKET));
//	packet->ip.TTL = 64;
//	packet->ip.Protocol = IPPROTO_TCP;
//	packet->tcp.HdrLength = sizeof(WINDIVERT_TCPHDR) / sizeof(UINT32);
//	//packet->tcp.Rst = 1;
//	//packet->tcp.Ack = 1;
//}

Divertor::Divertor(void)
	: handle_(INVALID_HANDLE_VALUE) 
	, thread_(NULL)
{
}


Divertor::~Divertor(void)
{
}

const HANDLE& Divertor::handle()const
{ return handle_; }

void Divertor::setHandle(const HANDLE& handle)
{ handle_ = handle;}

void closeRemoteServer(HANDLE handle, WINDIVERT_ADDRESS& address, WINDIVERT_IPHDR* ip_header, WINDIVERT_TCPHDR* tcp_header)
{
	PACKET reset;
	PacketInit(&reset);
	reset.tcp.Rst = 1;
	reset.tcp.Ack = 1;
	reset.ip.SrcAddr       = ip_header->SrcAddr;
	reset.ip.DstAddr       = ip_header->DstAddr;
	reset.tcp.SrcPort      = tcp_header->SrcPort;
	reset.tcp.DstPort      = htons(80);
	reset.tcp.SeqNum       = tcp_header->SeqNum;
	reset.tcp.AckNum       = tcp_header->AckNum;
	WinDivertHelperCalcChecksums((PVOID)&reset, sizeof(PACKET), 0);
	if (!WinDivertSend(handle, (PVOID)&reset, sizeof(PACKET), &address, NULL))
	{
		fprintf(stderr, "warning: failed to send reset packet (%d)\n",
			GetLastError());
	}
}

void sendDelegateData(HANDLE handle, WINDIVERT_ADDRESS& address, WINDIVERT_IPHDR* ip_header, WINDIVERT_TCPHDR* tcp_header, unsigned char* data, UINT payload_len)
{
	vector<unsigned char> sendingData;
	copy(data, data + payload_len, back_inserter(sendingData));
	Debugger::instance().outputPlain(sendingData);
	vector<unsigned char> receivedData = Client::instance().send(sendingData);
	if (receivedData.size() <= 0)
		return;
	UINT blockpage_len = sizeof(DATAPACKET) + receivedData.size(); //sizeof(block_data) - 1;
	Debugger::instance().output(TEXT("blockpage length:"), blockpage_len);
	PDATAPACKET blockpage = (PDATAPACKET)malloc(blockpage_len);
	if (blockpage == NULL)
	{
		fprintf(stderr, "error: memory allocation failed\n");
		exit(EXIT_FAILURE);
	}
	PacketInit(&blockpage->header);
	blockpage->header.ip.Length   = htons((short)blockpage_len);
	blockpage->header.tcp.SrcPort = htons(80);
	blockpage->header.tcp.Psh     = 1;
	blockpage->header.tcp.Ack     = 1;
	memcpy(blockpage->data, &receivedData[0], receivedData.size());

	//UINT32 destination = ip_header->DstAddr;
	blockpage->header.ip.SrcAddr       = ip_header->DstAddr;
	blockpage->header.ip.DstAddr       = ip_header->SrcAddr;
	blockpage->header.tcp.DstPort      = tcp_header->SrcPort;
	blockpage->header.tcp.SeqNum       = tcp_header->AckNum;
	blockpage->header.tcp.AckNum       = htonl(ntohl(tcp_header->SeqNum) + payload_len);
	WinDivertHelperCalcChecksums((PVOID)blockpage, blockpage_len, 0);
	address.Direction = !address.Direction;     // Reverse direction.
	if (!WinDivertSend(handle, (PVOID)blockpage, blockpage_len, &address, NULL))
		fprintf(stderr, "warning: failed to send block page packet (%d)\n", GetLastError());
	free(blockpage);
}

void finish(HANDLE handle, WINDIVERT_ADDRESS& address, WINDIVERT_IPHDR* ip_header, WINDIVERT_TCPHDR* tcp_header, UINT payload_len)
{
	PACKET finish;
	PacketInit(&finish);
	finish.tcp.Fin = 1;
	finish.tcp.Ack = 1;
	finish.ip.SrcAddr       = ip_header->DstAddr;
	finish.ip.DstAddr       = ip_header->SrcAddr;
	finish.tcp.SrcPort      = htons(80);
	finish.tcp.DstPort      = tcp_header->SrcPort;
	finish.tcp.SeqNum       = htonl(ntohl(tcp_header->AckNum) + sizeof(block_data) - 1); 
	finish.tcp.AckNum       = htonl(ntohl(tcp_header->SeqNum) + payload_len);
	Debugger::instance().output(TEXT("SentDataLength:"), sizeof(block_data) - 1);
	Debugger::instance().output(TEXT("payloadLength:"), payload_len);
	//outputPacket(finish);
	WinDivertHelperCalcChecksums((PVOID)&finish, sizeof(PACKET), 0);
	if (!WinDivertSend(handle, (PVOID)&finish, sizeof(PACKET), &address, NULL))
		fprintf(stderr, "warning: failed to send finish packet (%d)\n", GetLastError());
}

void delegateData(HANDLE handle,
		WINDIVERT_ADDRESS& address,
		WINDIVERT_IPHDR* ipHeader,
		WINDIVERT_TCPHDR* tcpHeader,
		unsigned char* data,
		UINT dataLength)
{
	closeRemoteServer(handle, address, ipHeader, tcpHeader);
	sendDelegateData(handle, address, ipHeader, tcpHeader, data, dataLength);
	finish(handle, address, ipHeader, tcpHeader, dataLength);
}

void catchData(const HANDLE& handle)
{
	const size_t buffer_size = 65535;
	vector<unsigned char> buffer(buffer_size);
	UINT payloadLength = 0;
	WINDIVERT_ADDRESS address = {0};
	if(!WinDivertRecv(handle, &buffer[0], buffer_size, &address, &payloadLength))
		return;
	WINDIVERT_IPHDR* ipHeader;
	WINDIVERT_TCPHDR* tcpHeader;
	unsigned char* data;
	UINT dataLength;
	if (!WinDivertHelperParsePacket(&buffer[0],
				payloadLength,
				&ipHeader,
				NULL, NULL, NULL,
				&tcpHeader,
				NULL,
				(PVOID*)&data,
				&dataLength))
		return;
	//delegateData(handle, address, ipHeader, tcpHeader, data, dataLength);
	closeRemoteServer(handle, address, ipHeader, tcpHeader);
	sendDelegateData(handle, address, ipHeader, tcpHeader, &buffer[0], payloadLength);
	finish(handle, address, ipHeader, tcpHeader, dataLength);
}

DWORD WINAPI threadProc(LPVOID param)
{
	Divertor* divertor = static_cast<Divertor*>(param);
	HANDLE handle = WinDivertOpen(divertor->filter().c_str(), WINDIVERT_LAYER_NETWORK, 0, 0);
	if (handle == INVALID_HANDLE_VALUE)
	{
		Debugger::instance().output(TEXT("Create Divert failed."), GetLastError());
		return CREATE_WINDIVERT_FAILED;
	}
	divertor->setHandle(handle);
	while(handle != INVALID_HANDLE_VALUE)
	{
		catchData(handle);
		handle = divertor->handle();
	}
	return 0;
}

bool Divertor::start(const string& filter)
{
	HANDLE thread = CreateThread(NULL, 0, threadProc, this, 0, 0);
	if (!thread)
		return false;
	setFilter(filter);
	setThread(thread);	
	return true;
}

void Divertor::setThread(const HANDLE& value)
{ thread_ = value;}

const HANDLE& Divertor::thread()const 
{ return thread_; }


const string& Divertor::filter()const
{ return filter_; }

void Divertor::setFilter(const string& value)
{ filter_ = value;}

void Divertor::terminate()
{
	if (thread())
		if (handle())
		{
			WinDivertClose(handle());
			setHandle(INVALID_HANDLE_VALUE);
		}
}
