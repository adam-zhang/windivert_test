#include "stdafx.h"
#include "Interceptor.h"
#include "Proxy.h"
#include "error.h"
#include "Packet.h"
#include <windivert.h>
#include <cassert>
#include <vector>
#include <memory>

using namespace std;

#define MAX_BUFFER 0xffff

class website
{
public:
	website(const std::string& url, int port)
		: url_(url)
		, port_(port) {}
private:
	std::string url_;
	int port_;
public:
	const std::string& url()const
	{ return url_;}
	void setUrl(const std::string& url)
	{ url_ = url;}
	const int& port()const
	{ return port_;}
	void setPort(const int& port)
	{ port_ = port;}
};

typedef struct
{
    WINDIVERT_IPHDR  ip;
    WINDIVERT_TCPHDR tcp;
} PACKET, *PPACKET;

const char block_data[] = 
	"HTTP/1.1 400 Bad Request\r\n"
	"Server: CloudFront\r\n"
	"Date: Sat, 30 Sep 2017 08:06:51 GMT\r\n"
	"Content-Type: text/html\r\n"
	"Content-Length: 551\r\n"
	"Connection: close\r\n"
	"X-Cache: Error from cloudfront\r\n"
	"Via: 1.1 c6d88d36c0be0174a24748de08dfae6b.cloudfront.net (CloudFront)\r\n"
	"X-Amz-Cf-Id: K4vqVxFPID7WYDTwsOBUc72KJYMVkhnH1vYj-2YpikNKT6ewp3il0w==\r\n\r\n"
	"<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">"
	"<HTML><HEAD><META HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html; charset=iso-8859-1\">"
	"<TITLE>ERROR: The request could not be satisfied</TITLE>"
	"</HEAD><BODY>"
	"<H1>ERROR</H1>"
	"<H2>The request could not be satisfied.</H2>"
	"<HR noshade size=\"1px\">"
	"Bad request."
	"<BR clear=\"all\">"
	"<HR noshade size=\"1px\">"
	"<PRE>"
	"Generated by cloudfront (CloudFront)"
	"Request ID: K4vqVxFPID7WYDTwsOBUc72KJYMVkhnH1vYj-2YpikNKT6ewp3il0w=="
	"</PRE>"
	"<ADDRESS>"
	"</ADDRESS>"
	"</BODY></HTML>";

typedef struct 
{
    PACKET header;
    UINT8 data[];
} DATAPACKET, *PDATAPACKET;

Interceptor::Interceptor()
	: handle_(INVALID_HANDLE_VALUE)
	, threadHandle_(NULL)
{
}


Interceptor::~Interceptor(void)
{
	if (handle_ != INVALID_HANDLE_VALUE)
		WinDivertClose(handle_);	
}

void Interceptor::addFilter(const string& url, int port)
{
	websites_.push_back(make_shared<website>(url, port));
}

static string buildPorts(const vector<shared_ptr<website>>& websites)
{
	stringstream ss;
	for(auto website : websites)
		ss << "tcp.DstPort==" << website->port() << " &&";
	return ss.str();
}

static string buildFilter(Interceptor& interceptor)
{
	stringstream ss;
	ss << "outbound && ip && " << buildPorts(interceptor.websites()) << " tcp.PayloadLength > 1";
	return ss.str();
}

static shared_ptr<Packet> getData(const unsigned char* dataPacket, size_t length)
{
	shared_ptr<Packet> packet = make_shared<Packet>();
	WINDIVERT_IPHDR* ipHeader = 0;
	WINDIVERT_TCPHDR* tcpHeader = 0;
	size_t dataLength = 0;
	unsigned char* data = 0;
	if (!WinDivertHelperParsePacket(data, length, &ipHeader, NULL, NULL, NULL, &tcpHeader, NULL, (PVOID*)&data, &dataLength))
	{
		outputDebugString(TEXT("Parse packet failed."), 0);
		return packet;
	}
	packet->setIpHeader(*ipHeader);
	packet->setTcpHeader(*tcpHeader);
	packet->setData(data, dataLength);
	return packet;
}


void initializePacket(PACKET& packet)
{
	packet.ip.Version = 4;
	packet.ip.HdrLength = sizeof(WINDIVERT_IPHDR) / sizeof(UINT32);
	packet.ip.Length = htons(sizeof(PACKET));
	packet.ip.TTL = 64;
	packet.ip.Protocol = IPPROTO_TCP;
	packet.tcp.HdrLength = sizeof(WINDIVERT_TCPHDR) / sizeof(UINT32);
}

void closeRemoteServer(HANDLE handle, const WINDIVERT_IPHDR& ip_header, const WINDIVERT_TCPHDR& tcp_header, WINDIVERT_ADDRESS& addr)
{
	PACKET reset;
	initializePacket(reset);
	reset.tcp.Rst = 1;
	reset.tcp.Ack = 1;
	reset.ip.SrcAddr       = ip_header.SrcAddr;
	reset.ip.DstAddr       = ip_header.DstAddr;
	reset.tcp.SrcPort      = tcp_header.SrcPort;
	reset.tcp.DstPort      = htons(80);
	reset.tcp.SeqNum       = tcp_header.SeqNum;
	reset.tcp.AckNum       = tcp_header.AckNum;
	WinDivertHelperCalcChecksums((PVOID)&reset, sizeof(PACKET), 0);
	if (!WinDivertSend(handle, (PVOID)&reset, sizeof(PACKET), &addr, NULL))
	{
		fprintf(stderr, "warning: failed to send reset packet (%d)\n",
			GetLastError());
	}
}

void closeRemoteServer(HANDLE handle, const shared_ptr<Packet>& packet, WINDIVERT_ADDRESS& address)
{
	closeRemoteServer(handle, packet->ipHeader(), packet->tcpHeader(), address);
}

void blockPage(HANDLE handle,
			   const WINDIVERT_IPHDR & ip_header,
			   const WINDIVERT_TCPHDR& tcp_header,
			   WINDIVERT_ADDRESS& addr,
			   const vector<unsigned char>& data,
			   size_t payloadLength)
{
	UINT blockpage_len = sizeof(DATAPACKET) + sizeof(block_data); //data.size() ;
	//outputDebugString(TEXT("blockpage length:"), blockpage_len);
	PDATAPACKET blockpage = (PDATAPACKET)malloc(blockpage_len);
	if (blockpage == NULL)
	{
		fprintf(stderr, "error: memory allocation failed\n");
		exit(EXIT_FAILURE);
	}
	initializePacket(blockpage->header);
	blockpage->header.ip.Length   = htons(blockpage_len);
	blockpage->header.tcp.SrcPort = htons(80);
	blockpage->header.tcp.Psh     = 1;
	blockpage->header.tcp.Ack     = 1;
	//memcpy(blockpage->data, &data[0], data.size());
	memcpy(blockpage->data, block_data, sizeof(block_data));

	blockpage->header.ip.SrcAddr       = ip_header.DstAddr;
	blockpage->header.ip.DstAddr       = ip_header.SrcAddr;
	blockpage->header.tcp.DstPort      = tcp_header.SrcPort;
	blockpage->header.tcp.SeqNum       = tcp_header.AckNum;
	blockpage->header.tcp.AckNum       = htonl(ntohl(tcp_header.SeqNum) + payloadLength);
	WinDivertHelperCalcChecksums((PVOID)blockpage, blockpage_len, 0);
	addr.Direction = !addr.Direction;     // Reverse direction.
	if (!WinDivertSend(handle, (PVOID)blockpage, blockpage_len, &addr, NULL))
		fprintf(stderr, "warning: failed to send block page packet (%d)\n", GetLastError());
	free(blockpage);
}
void sendDataToClient(HANDLE handle, const shared_ptr<Packet>& packet, WINDIVERT_ADDRESS& address, const vector<unsigned char>& data, size_t payloadLength)
{
	blockPage(handle, packet->ipHeader(), packet->tcpHeader(), address, data, payloadLength);	
}


void finishBlock(HANDLE handle,
				 const WINDIVERT_IPHDR& ip_header,
				 const WINDIVERT_TCPHDR& tcp_header,
				 WINDIVERT_ADDRESS& addr,
				 size_t sentLength,
				 UINT payload_len
				 )
{
	PACKET finish;
	initializePacket(finish);
	finish.tcp.Fin = 1;
	finish.tcp.Ack = 1;
	finish.ip.SrcAddr       = ip_header.DstAddr;
	finish.ip.DstAddr       = ip_header.SrcAddr;
	finish.tcp.SrcPort      = htons(80);
	finish.tcp.DstPort      = tcp_header.SrcPort;
	finish.tcp.SeqNum       = htonl(ntohl(tcp_header.AckNum) + sentLength); 
	finish.tcp.AckNum       = htonl(ntohl(tcp_header.SeqNum) + payload_len);
	outputInfo(TEXT("sentlength"), sentLength);
	outputInfo(TEXT("payloadLength"), payload_len);
	WinDivertHelperCalcChecksums((PVOID)&finish, sizeof(PACKET), 0);
	if (!WinDivertSend(handle, (PVOID)&finish, sizeof(PACKET), &addr, NULL))
	{
		fprintf(stderr, "warning: failed to send finish packet (%d)\n",
			GetLastError());
	}

}


void finish(HANDLE handle, const shared_ptr<Packet>& packet, WINDIVERT_ADDRESS& address, size_t payloadLength, size_t sentLength)
{
	finishBlock(handle, packet->ipHeader(), packet->tcpHeader(), address, sentLength, payloadLength);
}

void sendDataBack(HANDLE handle, const shared_ptr<Packet>& packet, WINDIVERT_ADDRESS& address, const vector<unsigned char>& data, size_t payloadLength)
{
	closeRemoteServer(handle, packet, address);
	sendDataToClient(handle, packet, address, data, payloadLength);
	finish(handle, packet, address, payloadLength, data.size());
}

void catchData(HANDLE handle)
{
	vector<unsigned char> buffer(MAX_BUFFER);
	WINDIVERT_ADDRESS address = {0};
	size_t length = 0;
	if (!WinDivertRecv(handle, &buffer[0], MAX_BUFFER, &address, &length))
	{
		outputDebugString(TEXT("WinDivertRecv failed. "), length);
		return;
	}
	shared_ptr<Packet> data = getData(&buffer[0], length);
	vector<unsigned char> param;
	copy(&buffer[0], &buffer[0] + length, back_inserter(param));
	vector<unsigned char> result = Proxy::instance().send(param);
	outputInfo(TEXT("result"), result);
	if (result.size() > 0)
		sendDataBack(handle, data, address, result, length);
}

DWORD WINAPI catchDataFunction(PVOID argument)
{
	Interceptor* interceptor = reinterpret_cast<Interceptor*>(argument);
	interceptor->setHandle(WinDivertOpen(interceptor->filter().c_str(), WINDIVERT_LAYER_NETWORK, 0, 0));	
	if (interceptor->handle() == INVALID_HANDLE_VALUE)
	{	
		outputDebugString(TEXT("WinDivertOpen failed."), GetLastError());
		return false;
	}
	for(;;)
		catchData(interceptor->handle());
	WinDivertClose(interceptor->handle());
	return 0;
}


bool Interceptor::monitor()
{
	string filter = buildFilter(*this);
	return monitor(filter);
}

bool Interceptor::monitor(const string& filter)
{
	setFilter(filter);
	HANDLE handle = CreateThread(NULL, 0, catchDataFunction, this, 0, 0);
	assert(handle);
	return true;
}

void Interceptor::setHandle(const HANDLE& handle)
{ 
	handle_ = handle;
}
